<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Tasker  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="Tasker  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">Tasker 0.12.0 Docs</a></p>
        <p class="header-right"><a href="https://www.github.com/aliak00/Tasker"><img src="img/gh.png"/>View on GitHub</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">Tasker Reference</a>
        <img id="carat" src="img/carat.png" />
        Tasker  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Task%20Management.html">Task Management</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/Task.html">Task</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/TaskError.html">TaskError</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/TaskState.html">TaskState</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/Handle.html">Handle</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/TaskManager.html">TaskManager</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/Interceptor.html">Interceptor</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/InterceptCommand.html">InterceptCommand</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/Reactor.html">Reactor</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ReactorConfiguration.html">ReactorConfiguration</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Logging.html">Logging</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/Logger.html">Logger</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/LogTags.html">LogTags</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/LogLevel.html">LogLevel</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="AnyTask.html">AnyTask</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/AnyTask.html">AnyTask</a>
              </li>
              <li class="nav-group-task">
                <a href="AnyTask.html#/s:6Tasker4task11closingOverAA7AnyTaskCyxGxyXA_tlF">task(closingOver:)</a>
              </li>
              <li class="nav-group-task">
                <a href="AnyTask.html#/s:6Tasker4task9executingAA7AnyTaskCyytGyyycc_tF">task(executing:)</a>
              </li>
              <li class="nav-group-task">
                <a href="AnyTask.html#/s:6Tasker4task9executingAA7AnyTaskCyxGyyxcc_tlF">task(executing:)</a>
              </li>
              <li class="nav-group-task">
                <a href="AnyTask.html#/s:6Tasker4task9executingAA7AnyTaskCyxGyys6ResultOyxs5Error_pGcc_tlF">task(executing:)</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Async%20Await.html">Async Await</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Async%20Await.html#/s:6Tasker5await7timeout5blockx8Dispatch0E12TimeIntervalOSg_yyxcctKlF">await(timeout:block:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Async%20Await.html#/s:6Tasker5await7timeout5blocky8Dispatch0E12TimeIntervalOSg_yyyXEctKF">await(timeout:block:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Async%20Await.html#/s:6Tasker5await7timeout5blockx8Dispatch0E12TimeIntervalOSg_yys6ResultOyxs5Error_pGcctKlF">await(timeout:block:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Async%20Await.html#/s:6Tasker5curryyq0_q_cxcq0_x_q_tcr1_lF">curry(_:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Async%20Await.html#/s:6Tasker5curryyq1_q0_cx_q_tcq1_x_q_q0_tcr2_lF">curry(_:)</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="URL%20Session%20Interceptor.html">URL Session Interceptor</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/URLTaskManager.html">URLTaskManager</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/URLTask.html">URLTask</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/URLTaskInterceptor.html">URLTaskInterceptor</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/URLTaskReactor.html">URLTaskReactor</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/URLTaskManagerError.html">URLTaskManagerError</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Other%20Extensions.html">Other Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Extensions/Array.html">Array</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Other%20Functions.html">Other Functions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Other%20Functions.html#/s:6Tasker5async11closingOver10completionyxyXA_ys6ResultOyxs5Error_pGcSgtlF">async(closingOver:completion:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Other%20Functions.html#/s:6Tasker5async9executingyyyc_tF">async(executing:)</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <h1 id='tasker-a-task-manager-with-async-await-and-url-session-management' class='heading'>Tasker - a task manager with async await and url session management</h1>

<p><strong>Warning</strong>: This is alpha software right now and is open to wiledly breaking suggestions</p>

<p><a href="http://cocoadocs.org/docsets/Tasker"><img src="https://img.shields.io/cocoapods/v/Tasker.svg?style=flat" alt="CocoaPods Version"></a>
<a href="https://github.com/Carthage/Carthage"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage compatible"></a>
<img src="https://github.com/aliak00/Tasker/workflows/Swift/badge.svg" alt="Swift">
<a href="https://travis-ci.org/aliak00/Tasker"><img src="https://travis-ci.org/aliak00/Tasker.svg?branch=master" alt="Build Status"></a>
<a href="https://codecov.io/gh/aliak00/Tasker"><img src="https://codecov.io/gh/aliak00/Tasker/branch/master/graph/badge.svg" alt="codecov"></a>
<a href="https://github.com/aliak00/Tasker/blob/master/LICENSE"><img src="https://img.shields.io/github/license/aliak00/Tasker.svg" alt="license"></a></p>

<p><a href="https://aliak00.github.io/Tasker/">Full API docs</a></p>

<ul>
<li><a href="#quick-look">Quick look</a></li>
<li><a href="#tasks">Tasks</a>

<ul>
<li><a href="#creating-a-task">Creating a task</a></li>
<li><a href="#starting-a-task">Starting a task</a></li>
<li><a href="#intercepting-a-task">Intercepting a task</a></li>
<li><a href="#reacting-to-a-task">Reacting to a task</a></li>
<li><a href="#cancelling-a-task">Cancelling a task</a></li>
<li><a href="#reintercepting-tasks-after-a-reaction">Reintercepting tasks after a reaction</a></li>
</ul></li>
<li><a href="#asyncawait">Async/Await</a>

<ul>
<li><a href="#as-free-functions-over-closures">As free functions over closures</a></li>
<li><a href="#on-an-array-of-tasks">On an array of tasks</a></li>
</ul></li>
<li><a href="#urltaskmanager">URLTaskManager</a>

<ul>
<li><a href="#intercepting-and-reacting">Intercepting and reacting.</a></li>
</ul></li>
<li><a href="#debugging-and-logging">Debugging and Logging</a></li>
</ul>

<p>Tasker is a task manager that&rsquo;s built on top of OperationQueue and GCD that has notions of <em>interception</em> and <em>reaction</em>. <code>Interceptors</code> allow you to modify a task before it&rsquo;s executed and also allow you to control the execution of a task (e.g. batch them, hold them, cancel them, etc.). <code>Reactors</code> allow you do something in reaction to the a task&rsquo;s completion <em>before</em> the result is passed to the caller (e.g. run a job, requeue the task, cancel the task, etc).</p>

<p>Tasker also provides task managerment of <code>URLSession</code> and async/await functionality</p>

<p>Features:</p>

<ul>
<li>Concurrent task management system</li>
<li>Task interception and enrichment</li>
<li>Task requeing and reaction functionnality</li>
<li>Spcialized URLSession handling to intercept and reactor to URLRequests</li>
<li>Async and await functionality</li>
<li>Async/await on an arrays of tasks</li>
</ul>
<h2 id='quick-look' class='heading'>Quick look</h2>
<pre class="highlight swift"><code><span class="c1">// Create a task object</span>
<span class="kd">class</span> <span class="kt">MyTask</span><span class="p">:</span> <span class="kt">Task</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="kt">SuccessValue</span> <span class="o">=</span> <span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">?,</span> <span class="nv">response</span><span class="p">:</span> <span class="kt">URLResponse</span><span class="p">?)</span>
    <span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="kt">CompletionCallback</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">request</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
                <span class="nf">completion</span><span class="p">(</span><span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nf">completion</span><span class="p">(</span><span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">response</span><span class="p">))</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Or create a task out of anything else</span>
<span class="k">let</span> <span class="nv">t</span> <span class="o">=</span> <span class="nf">task</span><span class="p">(</span><span class="nf">someLongRunningFunction</span><span class="p">())</span>

<span class="c1">// Run it in one of three ways:</span>

<span class="c1">// Await</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">MyTask</span><span class="o">.</span><span class="kt">SuccessValue</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">MyTask</span><span class="p">()</span><span class="o">.</span><span class="nf">await</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="nf">await</span><span class="p">()</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="c1">// error</span>
<span class="p">}</span>

<span class="c1">// Async</span>
<span class="kt">MyTask</span><span class="p">()</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
    <span class="c1">// got result</span>
<span class="p">}</span>

<span class="c1">// TaskManager</span>
<span class="kt">TaskManager</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">add</span><span class="p">(</span><span class="nv">task</span><span class="p">:</span> <span class="kt">MyTask</span><span class="p">())</span> <span class="p">{</span><span class="n">result</span> <span class="k">in</span>
    <span class="c1">// got result</span>
<span class="p">}</span>
</code></pre>
<h2 id='tasks' class='heading'>Tasks</h2>

<p>A task is any unit of work that is to be carried out. It is protocol based and has a main function called <code>execute</code> that is called when the task is supposed to be executed. When a task is completed, a callback with a <code>Result&lt;T, Error&gt;</code> is called by the implementation of the <code><a href="Protocols/Task.html">Task</a></code>.</p>

<p>E.g.</p>
<pre class="highlight swift"><code><span class="kd">class</span> <span class="kt">DecodeImage</span><span class="p">:</span> <span class="kt">Task</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="kt">Result</span><span class="o">&lt;</span><span class="kt">DecodedData</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fetchImageData</span> <span class="p">{</span> <span class="n">data</span> <span class="k">in</span>
            <span class="k">do</span> <span class="p">{</span>
                <span class="k">let</span> <span class="nv">decodedData</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="nf">decode</span><span class="p">()</span>
                <span class="nf">completion</span><span class="p">(</span><span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">decodedData</span><span class="p">))</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
                <span class="nf">completion</span><span class="p">(</span><span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre>

<p>Note that tasks are <em>reference</em> types. They must be because they are easier to reason about and they can be intercepted and reacted to so if we made copies and passed them around you&rsquo;d have to be very careful with state. When a task is finished, the <code>completion</code> callback is called with the result of the task.</p>

<p>If for any reason, the task is cancelled, the task&rsquo;s <code>didCancel</code> function is called and you are free to handle that as you see fit. For e.g. </p>
<pre class="highlight swift"><code><span class="kd">class</span> <span class="kt">DecodeImage</span><span class="p">:</span> <span class="kt">Task</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">var</span> <span class="nv">task</span><span class="p">:</span> <span class="kt">URLSessionTask</span>
    <span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="kt">Result</span><span class="o">&lt;</span><span class="kt">Data</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">task</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">didCancel</span><span class="p">(</span><span class="n">with</span> <span class="nv">error</span><span class="p">:</span> <span class="kt">Error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Cancel your URLSessionTask</span>
        <span class="n">task</span><span class="o">.</span><span class="nf">cancel</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre>
<h3 id='creating-a-task' class='heading'>Creating a task</h3>

<p>There&rsquo;re a number of ways you can create a task. One is by implementing the <code><a href="Protocols/Task.html">Task</a></code> protocol, as we&rsquo;ve seen above. And then there&rsquo;re a number of other ways:</p>

<ol>
<li><code><a href="Classes/AnyTask.html">AnyTask</a></code>: This type can be used to create a task out of a block
<code>swift
AnyTask { 5 } // Task that returns 5, no failure value
AnyTask { Result&lt;Int, Error&gt;.success(5) } // Task that returns Result&lt;T, Error&gt;
AnyTask { cb in cb(.success(5)) } // Task that calls the done callback
</code></li>
<li><code><a href="AnyTask.html#/s:6Tasker4task11closingOverAA7AnyTaskCyxGxyXA_tlF">task(closingOver:)</a></code>: This creates a task closing over it&rsquo;s value
<code>swift
let t = task(closingOver: someLongOperation())
</code></li>
<li><code><a href="AnyTask.html#/s:6Tasker4task9executingAA7AnyTaskCyytGyyycc_tF">task(executing:)</a></code>: Creates a task out of functions that have a compatable <code>done</code> callback:
<code>swift
let f1: (() -&gt; T) -&gt; Void = //...
let t1 = task(executing: f1)
let f2: (() -&gt; Result&lt;T, Error&gt;) -&gt; Void = //...
let t2 = task(executing: f2)
</code></li>
</ol>
<h3 id='starting-a-task' class='heading'>Starting a task</h3>

<p>To start a task you can either</p>

<ol>
<li>create a <code><a href="Classes/TaskManager.html">TaskManager</a></code> instance</li>
<li>use the default one provided</li>
<li>call <code><a href="Other%20Functions.html#/s:6Tasker5async11closingOver10completionyxyXA_ys6ResultOyxs5Error_pGcSgtlF">async(...)</a></code> or <code><a href="Async%20Await.html#/s:6Tasker5await7timeout5blockx8Dispatch0E12TimeIntervalOSg_yyxcctKlF">await(...)</a></code> on it</li>
</ol>
<pre class="highlight swift"><code><span class="c1">// Create a task</span>
<span class="k">let</span> <span class="nv">manager</span> <span class="o">=</span> <span class="kt">TaskManager</span><span class="p">()</span>
<span class="n">manager</span><span class="o">.</span><span class="nf">add</span><span class="p">(</span><span class="nv">task</span><span class="p">:</span> <span class="kt">DecodeImage</span><span class="p">())</span>

<span class="c1">// Use the default</span>
<span class="kt">TaskManager</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">add</span><span class="p">(</span><span class="nv">task</span><span class="p">:</span> <span class="kt">DecodeImage</span><span class="p">())</span>
</code></pre>

<p>Tasks are started as soon as you add them. You can also choose to start one later, or after a specific interval:</p>
<pre class="highlight swift"><code><span class="c1">// Start a task later:</span>
<span class="k">let</span> <span class="nv">handle</span> <span class="o">=</span> <span class="kt">TaskManager</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">add</span><span class="p">(</span><span class="nv">task</span><span class="p">:</span> <span class="kt">DecodeImage</span><span class="p">(),</span> <span class="nv">startImmediately</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
<span class="c1">// ...</span>
<span class="n">handle</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span>

<span class="c1">// Start a task after some interval</span>
<span class="kt">TaskManager</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">add</span><span class="p">(</span><span class="nv">task</span><span class="p">:</span> <span class="kt">DecodeImage</span><span class="p">(),</span> <span class="nv">after</span><span class="p">:</span> <span class="o">.</span><span class="nf">seconds</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
</code></pre>

<p>Everytime you add a task you get back a handle that can start or cancel a task. You can also query the state of a task, each task is given an incremented identifier.</p>
<h3 id='intercepting-a-task' class='heading'>Intercepting a task</h3>

<p>Every task is <em>intercepted</em> before it is executed by the <code><a href="Classes/TaskManager.html">TaskManager</a></code> that owns it. You can control how a task is intercepted by implementing a <code><a href="Protocols/Interceptor.html">Interceptor</a></code>, which has one method:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="n">intercept</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Task</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">task</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">T</span><span class="p">,</span> <span class="nv">currentBatchCount</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">InterceptCommand</span>
</code></pre>

<p>Intercept is called with a reference to the task that is about to be executed. You can modify the reference to the task and the command you return will determine what happens to the task. One of the parameters is a <code>currentBatchCount</code>; this is there because you can <code>hold</code> a task, so this tells you how many is held. Useful for batching events to an analytics system for e.g. See the docs for details on <code><a href="Enums/InterceptCommand.html">InterceptCommand</a></code>.</p>

<p>You enable an interceptor by passing an array of interceptors to a <code><a href="Classes/TaskManager.html">TaskManager</a></code> object upon creation only.</p>
<h3 id='reacting-to-a-task' class='heading'>Reacting to a task</h3>

<p>After a task is done executing, it&rsquo;s time for reactors to be called. <code><a href="Protocols/Reactor.html">Reactor</a></code>s allow you to re-process a task if the need arises, or cancel a task that you deem unworthy to complete. You enable reactors by passing an array of them to a <code><a href="Classes/TaskManager.html">TaskManager</a></code> object upon creation (just like interceptors).</p>

<p>A reactor is first asked if it is supposed to execute. It is given the task that just completed, the result of that task&rsquo;s execution, and the task handle that owns it. If <code><a href="Protocols/Reactor.html#/s:6Tasker7ReactorP13shouldExecute5after4from4withSbs6ResultOy12SuccessValueQyd__s5Error_pG_qd__AA6Handle_ptAA4TaskRd__lF">Reactor.shouldExecute(...)</a></code> returns true, then <code><a href="Protocols/Reactor.html#/s:6Tasker7ReactorP7execute4doneyys5Error_pSgc_tF">Reactor.execute(...)</a></code> function is called.</p>

<p>Every reactor can have its own <code><a href="Structs/ReactorConfiguration.html">ReactorConfiguration</a></code>, which can control how the <code><a href="Classes/TaskManager.html">TaskManager</a></code> behaves while a reaction is in progress. For example if you want no more tasks to be executed while you are executing the reactor, or if you want to re-execute the task that caused this reaction, after the reactor is done.</p>
<h3 id='cancelling-a-task' class='heading'>Cancelling a task</h3>

<p>Whenever you add a task to a task manager, you get back a handle that is unique to that task. The <code><a href="Protocols/Handle.html">Handle</a></code> can be used to cancel a task.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">handle</span> <span class="o">=</span> <span class="kt">TaskManager</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">add</span><span class="p">(</span><span class="nv">task</span><span class="p">:</span> <span class="kt">DecodeImage</span><span class="p">(),</span> <span class="nv">startImmediately</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
<span class="c1">// ...</span>
<span class="n">handle</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span>
</code></pre>

<p>And then <code><a href="Protocols/Task.html#/s:6Tasker4TaskP9didCancel4withyAA0B5ErrorO_tF">Task.didCancel(...)</a></code>  is called in response to that with <code><a href="Enums/TaskError.html#/s:6Tasker9TaskErrorO9cancelledyA2CmF">TaskError.cancelled</a></code>. The <code>didCancel</code> method could also be called as a result of other errors.</p>
<h3 id='reintercepting-tasks-after-a-reaction' class='heading'>Reintercepting tasks after a reaction</h3>

<p>An interceptor is only run once on a task by default. The case where you would want to re-reun an interceptor would be if a reaction caused a requeuing of the task. In that case, whether or not a task is reintercepted depends on the reactor configuration. You can set <code>ReactorConfiguration.reinterceptOnRequeue</code> to control this behavior.</p>
<h2 id='async-await' class='heading'>Async/Await</h2>

<p>Async await functionality comes out of the box with Tasker. You can execute a <code><a href="Protocols/Task.html">Task</a></code> you create directly synchronously or asynchronously by calling the extension <code>async</code> or <code>await</code> functions on your task:</p>
<pre class="highlight swift"><code><span class="k">do</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">DecodeImage</span><span class="p">()</span><span class="o">.</span><span class="nf">await</span><span class="p">()</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</code></pre>

<p>Or:</p>
<pre class="highlight swift"><code><span class="kt">DecodeImage</span><span class="p">()</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<h3 id='as-free-functions-over-closures' class='heading'>As free functions over closures.</h3>

<p><code>async</code> can be called on any expression as an <code>@autoclosure</code>:</p>
<pre class="highlight swift"><code> <span class="nf">async</span><span class="p">(</span><span class="nf">loadVideoFileSync</span><span class="p">())</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">result</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">videoFile</span><span class="p">):</span>
        <span class="k">break</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
        <span class="k">break</span>
 <span class="p">}</span>
</code></pre>

<p>And <code>await</code> can be called on any closure that has the following signatures:</p>

<ul>
<li><code>@escaping (@escaping (T) -&gt; Void) -&gt; Void</code></li>
<li><code>@escaping (@escaping () -&gt; Void) -&gt; Void</code></li>
<li><code>@escaping (@escaping (Result&lt;T, Error&gt;) -&gt; Void) -&gt; Void</code></li>
</ul>

<p>Each of the closures has a single parameter. One that returns a <code>T</code> which is the result of the <code>await</code> operation. One that retuns nothing, i.e. <code>await</code> returns <code>Void</code> and one that returns a <code>Result&lt;T, Error&gt;</code> object. If the result is a failure, then <code>await</code> throws.</p>

<p>E.g.:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">number</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">await</span> <span class="p">{</span> <span class="p">(</span><span class="nv">done</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="k">in</span>
    <span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">(</span><span class="nv">qos</span><span class="p">:</span> <span class="o">.</span><span class="n">unspecified</span><span class="p">)</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
        <span class="c1">// Do some long running calculation</span>
        <span class="nf">done</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// return 5</span>
    <span class="p">}</span>
<span class="p">}</span>

 <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
<h3 id='on-an-array-of-tasks' class='heading'>On an array of tasks</h3>

<p>There are extensions available on the <code>Array</code> type that you can use to call <code>async</code> or <code>await</code> on an array of tasks of the same type.</p>

<p>E.g:</p>
<pre class="highlight swift"><code><span class="k">var</span> <span class="nv">tasks</span><span class="p">:</span> <span class="p">[</span><span class="kt">Task</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="mi">10</span> <span class="p">{</span>
    <span class="n">tasks</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="kt">AnyTask</span> <span class="p">{</span> <span class="n">i</span> <span class="p">})</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">results</span> <span class="o">=</span> <span class="k">try!</span> <span class="n">tasks</span><span class="o">.</span><span class="nf">await</span><span class="p">()</span>
</code></pre>

<p>You can choose to execute the tasks in order or not.</p>
<h2 id='urltaskmanager' class='heading'>URLTaskManager</h2>

<p>The idea behind the URLTaskManager is that it creates a URLSession object that is tied to a <code><a href="Classes/TaskManager.html">TaskManager</a></code> so that you can call interceptors and reactors on <code>URLRequest</code>s. This is very useful for example if you need to add headers to all your requests that are going out. You simply add an interceptor that inserts an authorization header. If for e.g. you need to refresh any tokens after a <code>URLRequest</code> fails, a reactor can come in handy - requeue the task, fetch a new auth token, and done.</p>

<p>To create a URLTaskManager you can optionally pass in a <code>URLSessionConfiguration</code> (just as you would when creating a <code>URLSession</code> object), and an array of <code><a href="Protocols/URLTaskInterceptor.html">URLTaskInterceptor</a></code>s and <code><a href="Protocols/URLTaskReactor.html">URLTaskReactor</a></code>s:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">urlTaskManager</span> <span class="o">=</span> <span class="kt">URLTaskManager</span><span class="p">(</span><span class="nv">interceptors</span><span class="p">:</span> <span class="p">[</span><span class="kt">MyInterceptor</span><span class="p">()],</span> <span class="nv">reactors</span><span class="p">:</span> <span class="p">[</span><span class="kt">Myreactors</span><span class="p">()])</span>
</code></pre>

<p>And then you use the internal <code>URLSession</code> object to make requests</p>
<pre class="highlight swift"><code><span class="n">urlTaskManager</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="kt">URL</span><span class="p">(</span><span class="o">...</span><span class="p">))</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
    <span class="c1">// the URLTask that's associated with this will be intercepted and reacted to</span>
    <span class="c1">// by MyInterceptor and MyReactor</span>
<span class="p">}</span>
</code></pre>
<h3 id='intercepting-and-reacting' class='heading'>Intercepting and reacting</h3>

<p>The <code><a href="Classes/URLTaskManager.html">URLTaskManager</a></code> works with a type <code><a href="Classes/URLTask.html">URLTask</a></code> which encapsulates a <code>URLRequest</code> object. The <code><a href="Classes/URLTask.html">URLTask</a></code> is  the <code><a href="Protocols/Task.html">Task</a></code> object that you can intercept with a <code><a href="Protocols/URLTaskInterceptor.html">URLTaskInterceptor</a></code> or react to with a <code><a href="Protocols/URLTaskReactor.html">URLTaskReactor</a></code>:</p>

<p>Here we create a task interceptor that contains a hypothetical user object and adds an authorization header for the user
object whenever the request is going to go out:</p>
<pre class="highlight swift"><code><span class="kd">class</span> <span class="kt">Interceptor</span><span class="p">:</span> <span class="kt">URLTaskInterceptor</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">func</span> <span class="nf">intercept</span><span class="p">(</span><span class="nv">task</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">URLTask</span><span class="p">,</span> <span class="n">currentBatchCount</span> <span class="nv">_</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">InterceptCommand</span> <span class="p">{</span>
        <span class="n">task</span>
            <span class="o">.</span><span class="n">request</span>
            <span class="o">.</span><span class="nf">addValue</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">authorization</span><span class="p">,</span> <span class="nv">forHTTPHeaderField</span><span class="p">:</span> <span class="s">"Authorization"</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">.</span><span class="n">execute</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>And here we have a reactor that also contains a hypothetical user object and performs a OAuth2 token refresh operation when the result is a 401 failure:</p>
<pre class="highlight swift"><code><span class="kd">class</span> <span class="kt">Reactor</span><span class="p">:</span> <span class="kt">URLTaskReactor</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">done</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Error</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// For example one could refresh the authorization tokens here</span>
        <span class="n">user</span><span class="o">.</span><span class="n">refreshAuthorizationToken</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
            <span class="k">switch</span> <span class="n">result</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">success</span><span class="p">:</span>
                <span class="nf">done</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
            <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="nf">done</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kd">func</span> <span class="nf">shouldExecute</span><span class="p">(</span><span class="n">after</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">URLT</span><span class="o">.</span><span class="kt">Result</span><span class="p">,</span> <span class="n">from</span> <span class="nv">task</span><span class="p">:</span> <span class="kt">URLTask</span><span class="p">,</span> <span class="n">with</span> <span class="nv">_</span><span class="p">:</span> <span class="kt">Handle</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
            <span class="c1">// One can return true if there's a 401 UNAUTHORIZED http response code.</span>
            <span class="k">if</span> <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="n">result</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="p">(</span><span class="n">response</span> <span class="k">as?</span> <span class="kt">HTTPURLResponse</span><span class="p">)?</span><span class="o">.</span><span class="n">statusCode</span> <span class="o">==</span> <span class="mi">401</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre>
<h2 id='debugging-and-logging' class='heading'>Debugging and Logging</h2>

<p>Logging facilities are provided by the library for debugging purposes mainly. To enable them you need to add a transport to the shared logger:</p>
<pre class="highlight swift"><code><span class="kt">Logger</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">addTransport</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
</code></pre>

<p>The above will log all messages to stdout. There&rsquo;s also a number of filters that can be applied if you want to debug certain parts. The filters revolve around tags and there&rsquo;re a number of redefined tags that the shared logger uses. See <code><a href="Structs/LogTags.html">LogTags</a></code> in the docs</p>

          </section>
        </section>
        <section id="footer">
          <p>© 2018-2020 Ali Akhtarzada</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.13.4</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
